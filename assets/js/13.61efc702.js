(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{494:function(t,s,a){"use strict";a.r(s);var r=a(4),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"mysql锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql锁"}},[t._v("#")]),t._v(" MySql锁")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[t._v("锁是计算机"),a("strong",[t._v("协调多个进程或者线程并发访问")]),t._v("某一资源的机制")]),t._v(" "),a("li",[t._v("锁冲突也是影响数据库并发访问性能一个因素。")])]),t._v(" "),a("h2",{attrs:{id:"锁的分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁的分类"}},[t._v("#")]),t._v(" 锁的分类")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("p",[t._v("从性能上可以分为"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("乐观锁")])]),t._v("（数据Version对比实现）和"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("悲观锁")])]),t._v("（类似于Java中的sychronized同步阻塞操作）")],1)]),t._v(" "),a("li",[a("p",[t._v("从数据库操作的类型分，分为"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("读锁")])]),t._v("和"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("写锁")])]),t._v("（都属于悲观锁）")],1),t._v(" "),a("ul",[a("li",[t._v("读锁（共享锁）：针对同一份数据，多个读操作可以同时进行，并且互不影响。")]),t._v(" "),a("li",[t._v("写锁（排他锁）：当前写操作没有完成前，他会阻塞其余的写锁和读锁。")])])]),t._v(" "),a("li",[a("p",[t._v("从数据操作的粒度分，分为"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("表锁")])]),t._v("和"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("行锁")])])],1)])]),t._v(" "),a("h2",{attrs:{id:"表锁（偏读）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表锁（偏读）"}},[t._v("#")]),t._v(" 表锁（偏读）")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("表锁偏MyISAM存储引擎，开销小，加锁快，无思索，粒度大，发生锁冲突的概率最高，并发度最低。")]),t._v(" "),a("p",[t._v("MyISAM不支持行锁！")]),t._v(" "),a("ul",[a("li",[t._v("加表锁")])]),t._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("lock")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" 表名"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("read")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("表名"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("read")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("read")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("write")]),t._v(":读"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("写锁\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"http://image-airlin.test.upcdn.net/class/mysql/mysql13.jpg"}}),t._v(" "),a("ul",[a("li",[t._v("查看表上加过的锁")])]),t._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("show")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("open")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("tables")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("ul",[a("li",[t._v("删除表锁")])]),t._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unlock")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("tables")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h3",{attrs:{id:"_1-加读锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-加读锁"}},[t._v("#")]),t._v(" 1.加读锁")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[t._v("以上图air_lock表为例（已经加上读锁）")]),t._v(" "),a("li",[t._v("当前Session和其他Session"),a("strong",[t._v("都可以读取")]),t._v("air_lock表，如下图：")])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"http://image-airlin.test.upcdn.net/class/mysql/mysql14.jpg"}}),t._v(" "),a("ul",[a("li",[t._v("当前Session对表做更新插入操作时会报错，其他Session做更新插入操作会阻塞。Mysql这样设计是因为读锁一般是在数据迁移的时候加上，在迁移的过程中我们不想让当前或者其他连接再对表的数据进行变更。\n"),a("ul",[a("li",[t._v("图1：其他Session做修改，图2：当前Session做修改")])])])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"http://image-airlin.test.upcdn.net/class/mysql/readLockupdate.gif"}}),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"http://image-airlin.test.upcdn.net/class/mysql/readLock2.jpg"}}),t._v(" "),a("h3",{attrs:{id:"_2-加写锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-加写锁"}},[t._v("#")]),t._v(" 2.加写锁")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("p",[t._v("以上图air_lock表为例（已经加上写锁）")])]),t._v(" "),a("li",[a("p",[t._v("当前Session对表的增删改查都没有问题，其他Session对表的任何操作都会被阻塞！如图")])])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"http://image-airlin.test.upcdn.net/class/mysql/writeLock1.gif"}}),t._v(" "),a("h3",{attrs:{id:"_3-总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-总结"}},[t._v("#")]),t._v(" 3.总结")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("p",[a("font",{attrs:{color:"red"}},[a("strong",[t._v("MyISAM存储引擎在执行SELECT前会给查询涉及到的所有表加上读锁，在执行增删改操作前会自动给涉及到的表叫上写锁")])])],1)]),t._v(" "),a("li",[a("p",[a("strong",[t._v("对MyISAM表的读操作")]),t._v("（加读锁）：不会阻塞其他进程对同一张表的读请求，但是"),a("strong",[t._v("会阻塞对同一表的写请求")]),t._v("。只有当读锁释放后，才会执行其他进程的写操作。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("对MyISAM表的写操作")]),t._v("（加写锁）："),a("strong",[t._v("会阻塞其他进程对同一张表的所有操作（增删改查）")]),t._v("，只有当写锁释放后，才会执行其他进程对表的操作。想当于Java中的同步。")])]),t._v(" "),a("li",[a("p",[a("font",{attrs:{color:"red"}},[a("strong",[t._v("读锁会阻塞写，不会阻塞读。写锁会阻塞读和写。")])]),t._v("因此读锁叫共享锁，而写锁叫排他锁。")],1)])]),t._v(" "),a("h2",{attrs:{id:"行锁-偏写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行锁-偏写"}},[t._v("#")]),t._v(" 行锁(偏写)")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[t._v("行锁偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁的粒度最小，发生锁冲突的概率最低，并发度也最高。\n"),a("ul",[a("li",[t._v("这也是InnoDB和MyISAM的区别：支持事务（TRANSACTION）和行锁。")])])])]),t._v(" "),a("h3",{attrs:{id:"_1-行锁支持事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-行锁支持事务"}},[t._v("#")]),t._v(" 1.行锁支持事务")]),t._v(" "),a("h3",{attrs:{id:"事务（transaction）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务（transaction）"}},[t._v("#")]),t._v(" 事务（Transaction）")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("概念："),a("strong",[t._v("事务是由一组SQL语句组成的")]),t._v("逻辑处理单元")]),t._v("，其ACID属性分别如下：")])]),t._v(" "),a("li",[a("p",[t._v("原子性，一致性研究的维度在"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("同一个事务中")])]),t._v("的相互影响")],1),t._v(" "),a("ul",[a("li",[t._v("原子性(Automicity)：逻辑处理单元对数据库的操作要么成功，要么失败。")]),t._v(" "),a("li",[t._v("一致性(Consistent)：事务一旦提交，其对数据库的该表是永久性的。接下来其他操作或故障都不应该对其有影响。")])])]),t._v(" "),a("li",[a("p",[t._v("隔离性，持久性研究的是"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("不同事务间的相互影响")])])],1),t._v(" "),a("ul",[a("li",[a("strong",[t._v("隔离性(Isolation)")]),t._v("：事务内部的操作与其他事务是隔离的，并发执行的各个事务不能相互干扰。不同事务间的研究主要分为以下两方面：\n"),a("ul",[a("li",[t._v("不同事务间写操作的影响：锁机制保证隔离；")]),t._v(" "),a("li",[t._v("不同事务间读操作的影响：MVCC保证隔离性；")])])]),t._v(" "),a("li",[t._v("持久性(Durable)：事务完成后，它对数据的修改是永久性的，即使出现系统故障也能保持。")])])])]),t._v(" "),a("h3",{attrs:{id:"_2-并发事务处理带来的问题："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-并发事务处理带来的问题："}},[t._v("#")]),t._v(" 2.并发事务处理带来的问题：")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("更新丢失（Lost Update）")]),t._v("：当多个事务更新同一行数据的时，由于不知道其他事务的存在。就会覆盖其他事务的更新，从而造成更新丢失。可用类似乐观锁的方案解决。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("脏读（Dirty Reads）")]),t._v("：事务B读取到了事务A未提交的数据（事务A可能回滚）。此时事务A的记录处于不一致的状态。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("不可重复读（Non-Repeatable Reads）")]),t._v("：事务B读取到了事务A已提交的数据，一个事务在读取某一行数据时，再次读取该行数据，数据发生改变或者已经删除。不符合隔离性。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("幻读（Phantom Reads）")]),t._v("：事务B读取到了事务A提交的新增数据")])])]),t._v(" "),a("h3",{attrs:{id:"事务隔离级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[t._v("#")]),t._v(" 事务隔离级别")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[t._v("数据库提供用来解决脏读，不可重复读，幻读的问题。")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("隔离级别")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("脏读")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("不可重复读")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("幻读")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("读未提交（Read Uncommited）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("可能")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("可能")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("可能")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("读已提交（Read Commited）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("不可能")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("可能")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("可能")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("重复度（Repeatable Read）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("不可能")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("不可能")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("可能")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("串行化（Serializable）")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("不可能")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("不可能")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("不可能")])])])]),t._v(" "),a("ul",[a("li",[t._v("隔离级别设置越高，并发的问题越少，但是付出的性能代价越高。事务隔离的实质就是使事务在一定程度串行化。\n"),a("ul",[a("li",[t._v("查看当前隔离级别：show variables like 'tx_isolation';")]),t._v(" "),a("li",[t._v("设置数据库隔离级别：set tx_isolation='REPEATABLE-READ'; （设置重复读）")])])])]),t._v(" "),a("h3",{attrs:{id:"实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例"}},[t._v("#")]),t._v(" 实例")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("strong",[t._v("读未提交 set tx_isolation = 'read-uncommitted';")]),t._v(" "),a("ul",[a("li",[t._v("可以看到设置事务隔离级别为读未提交后，右边的事务（下文统称B）读到了左边事务（下文统称A）的未提交的脏数据，所以无法脏读的问题。不可重复读和幻读都是不能解决的。")])])])]),t._v(" "),a("img",{staticStyle:{zoom:"40%"},attrs:{src:"http://image-airlin.test.upcdn.net/class/mysql/transa1.jpg"}}),t._v(" "),a("ul",[a("li",[a("strong",[t._v("读已提交 set tx_isolation = 'read-committed';")]),t._v(" "),a("ul",[a("li",[t._v("可以看到事务A并没有读取到事务B未提交的数据，因此可以解决脏读的问题。")])])])]),t._v(" "),a("img",{staticStyle:{zoom:"40%"},attrs:{src:"http://image-airlin.test.upcdn.net/class/mysql/trasa2.jpg"}}),t._v(" "),a("p",[t._v("​\t接着我把事务A提交后，再次查询account表，可以发现在一个事务中两次查询得到了不同结果，因此在程序中做的业务逻辑操作都是有问题的。也就是设置隔离级别为读已提交，解决不了不可重复读的问题。(幻读也解决不了)。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("重复读（mysql默认隔离级别）")]),t._v(" "),a("strong",[t._v("set tx_isolation = 'repeatable-read';")]),t._v(" "),a("ul",[a("li",[t._v("可以看到设置隔离级别为可重复读后，B事务的查询结果一致解决了不可重复读的问题")])])])]),t._v(" "),a("img",{staticStyle:{zoom:"40%"},attrs:{src:"http://image-airlin.test.upcdn.net/class/mysql/transa4.jpg"}}),t._v(" "),a("p",[t._v("​\t那么隔离级别为重复读是解决不了幻读的，接着我在A事务中新增记录。但是在B事务的查询中虽然不能看到id为4的新增记录。")]),t._v(" "),a("p",[t._v("更新的时候却能更新到id为4的记录行。说明事务B读到了事务A提交的新增数据。")]),t._v(" "),a("p",[t._v("​\t事务B查不到事务A提交的新增记录是因为"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("可重复读的MVCC机制")])]),t._v("，"),a("strong",[t._v("select操作不会更新版本号，是快照读（历史版本），但是insert,update,delete会更新版本号，是当前读（版本）。")])],1),t._v(" "),a("img",{staticStyle:{zoom:"40%"},attrs:{src:"http://image-airlin.test.upcdn.net/class/mysql/transa5.jpg"}}),t._v(" "),a("ul",[a("li",[t._v("串行化：类似于java中的同步关键字sychronized，同步执行，效率很低，一般不用。")])]),t._v(" "),a("h3",{attrs:{id:"_3-间隙锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-间隙锁"}},[t._v("#")]),t._v(" 3.间隙锁")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[t._v("间隙锁在"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("一定情况下可以解决可重复读隔离级别幻读的问题")])]),t._v("，但是比较少用。（图中对ACCOUNT表汇总5-7行上了锁，这样事务B无法对事务A做写的操作）。")],1)]),t._v(" "),a("img",{staticStyle:{zoom:"40%"},attrs:{src:"http://image-airlin.test.upcdn.net/class/mysql/transa6.gif"}}),t._v(" "),a("h3",{attrs:{id:"_4-行锁分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-行锁分析"}},[t._v("#")]),t._v(" 4.行锁分析")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[t._v("通过检查"),a("strong",[t._v("InnoDB_row_lock")]),t._v("状态变量来分析系统上的行锁竞争情况：\n"),a("ul",[a("li",[t._v("Innodb_row_lock_current_waits：当前正在等待锁定的数量。")]),t._v(" "),a("li",[t._v("Innodb_row_lock_time：从系统启动到现在锁定总时间长度。")]),t._v(" "),a("li",[a("font",{attrs:{color:"red"}},[a("strong",[t._v("Innodb_row_lock_time_avg：")])]),t._v("每次等待所花的平均时间。")],1),t._v(" "),a("li",[t._v("Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间")]),t._v(" "),a("li",[t._v("Innodb_row_lock_waits：从系统启动到现在所有的等待锁定数量。")])])])]),t._v(" "),a("h3",{attrs:{id:"_5-死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-死锁"}},[t._v("#")]),t._v(" 5.死锁")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("设置数据库默认隔离级别为可重复读,可以看到当事务B尝试获取第一行的锁的时候，发生了思索，mysql检测到了死锁异常，回滚了事务B，事务A获取到了第二行的行锁结束阻塞状态，查询到了id为2的数据。")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"http://image-airlin.test.upcdn.net/class/mysql/transa7.jpg"}}),t._v(" "),a("ul",[a("li",[a("p",[t._v("查看近期死锁日志信息")]),t._v(" "),a("ul",[a("li",[t._v("show engine innodb status\\G;")])])]),t._v(" "),a("li",[a("p",[t._v("Mysql大多数情况下都能回滚那个产生死锁的事务信息，但是有些情况mysql没法检测。")])])]),t._v(" "),a("h2",{attrs:{id:"注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("font",{attrs:{color:"red"}},[a("strong",[t._v("无索引的行锁升级为表锁")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("InnoDB的行锁是针对索引加的锁")]),t._v("，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级成表锁。")]),t._v(" "),a("li",[t._v("锁定某行还可以用lock in share model（共享锁）和for update（排它锁），例如：select * from 表名 where id = 1 for update 这样其他session只能读取这行数据，修改会被阻塞，直到锁的释放。")])])],1)]),t._v(" "),a("h2",{attrs:{id:"优化准则："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化准则："}},[t._v("#")]),t._v(" 优化准则：")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[t._v("尽可能让数据检索都通过索引来完成，"),a("font",{attrs:{color:"red"}},[a("strong",[t._v("避免无索引行行锁升级为表锁。")])])],1),t._v(" "),a("li",[t._v("合理设计索引，尽量减小锁的范围。")]),t._v(" "),a("li",[t._v("尽可能减少检索条件，避免间隙锁。")]),t._v(" "),a("li",[t._v("尽可能控制事务范围，减少锁定资源量和时间长度。")]),t._v(" "),a("li",[t._v("尽可能降低事务级别。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);